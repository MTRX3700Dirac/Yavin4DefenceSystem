\documentclass[]{article}

\usepackage{graphicx}
\usepackage{Bookmark}

%opening
\title{Testing Document}
\author{Grant Louat}

\begin{document}

\maketitle

\newpage

\begin{abstract}
This document details the testing of all functions, and their current state. Each function will be tested in isolation. This document should detail by what criteria the function has been deemed correct, the date and who did the testing. It should also have a listing of the working code so there is no confusion over different versions. This will quickly tell everyone which functions have been confirmed correct, and the rigour to which that assertion was made. It will also tell them when it was confirmed in case they have been working on a local copy of the code, and who deemed it correct in case they have questions. This document should also have a description of the function so that people know what the function should be doing when it is working.\newline
The document deals only with the isolation testing of each function. The functions will also need to be tested in an integration phase later. \newline
WARNING: DO NOT INCLUDE ANYTHING IN THIS DOCUMENT UNLESS YOU ARE CERTAIN THAT IT IS COMPLETELY ERROR FREE! \newline Even if it is a simple one line function there could be a type issue or something. Anything document will be assumed working, and if a single error remains it will nullify the entire document. If a function is too large or complex to test and verify in complete certainty then it should be split into smaller functions to solve parts of the problem. Make sure also to include WHY you verified the function correct, as your rigour may not meet the standard of someone else's.
\end{abstract}

\newpage
\section{Common}

\subsection{DIV\_X:}
\subsubsection{Status:}
Working as of 11:30 25/9/2014 - Grant

\subsubsection{Description:}
This set of Macros are designed to divide an integer by a power of two.

\subsubsection{Criteria:}
The value of 1024 was tested for each of the macros, and due to the simplicity and nature of the macros no other values need be tested.

\subsubsection{Working code:}
\#define DIV\_2(v) ((v) $>>$ 1)       //Divide by 2

\newpage
\section{Temperature Module:}

\subsection{ReadTempx2:}

\subsubsection{Status:}
Currently untested as of 8am 26/9/14 - Grant

\subsubsection{Description:}
Returns the temperature (x2) in degrees Celsius by performing an A/D conversion on the analogue output from the temperature sensor.

\subsection{ReadTemp:}
\subsubsection{Status:}
Working as of 8am 26/9/2014 - Grant

\subsubsection{Criteria:}
This function was tested in isolation of the ReadTempx2, and the assertion only applies to this function. A ReadTempx2 stub function was written to simply return the value of 40 to test the ReadTemp function.

\subsubsection{Description:}
The function simply calls the ReadTempx2 function and divides the result by 2.

\subsubsection{Working Code:}
unsigned char readTemp(void) \newline
\{ \newline
	unsigned char temp; \newline
	
	temp = readTempx2(); \newline
	
	return DIV\_2(temp); \newline
\} \newline

\subsection{RawTemp:}

\subsubsection{Status:}
Working as of 8:30am 26/9/2014 - Grant

\subsubsection{Criteria:}
The function was tested in isolation of the ReadTemp functions. A dummy function placed the value of 60 into the lastTempx2 variable, and the RawTemp function worked as described.

\subsubsection{Description:}
This function returns the uncalibrated result of the last temperature read. E.g. the raw sensor output. A temperature read is performed by either a ReadTemp or ReadTempx2 call. \newline:
This function cannot be completely tested in isolation as it requires an external static declaration of the lastTempx2 variable. It also requires the ReadTemp and ReadTempx2 functions to write to this variable when they perform a read.

\subsubsection{Working Code:}
unsigned char rawTemp(void) \newline
\{ \newline
	return DIV\_2(lastTempx2); \newline
\} \newline

\subsection{Calibrate Temp:}
\subsubsection{Status:}
Working as of 10:30am 26/9/2014 - Grant

\subsubsection{Description:}
Calibrates the last temperature read to the passed reference value by updating a static variable.

\subsubsection{Criteria:}
This function was tested in isolation of the readTemp functions. a dummy readTempx2 function which just returned 15deg (and set the static variable) was written, and the calibration function called to calibrate it to 20 deg, and then 10 deg. In both cases a second call of readTempx2 returned the desired value even though the 'raw data' was simply hard coded in.

\subsubsection{Working Code:}
void calibrateTemp(unsigned char reference) \newline
{ \newline
	calibration\_offset = 2 * (reference - DIV\_2(lastTempx2)); \newline
} \newline

\subsection{GetTemp:}

\subsubsection{Status:}
Working as of 10:30 26/9/2014 - Grant

\subsubsection{Description:}
Returns the result of the last temperature read.

\subsubsection{Criteria:}
This is just an accessor function, so it simply returns the value of a static variable.

\subsubsection{Working Code:}
unsigned char getTemp(void) \newline
{ \newline
	return DIV\_2(lastTempx2); \newline
} \newline

\newpage
\section{Range}

\subsection{SPD\_SND Macro}
\subsubsection{Status:}
Working as of 10:30 25/9/14 - Grant

\subsubsection{Description:}
This macro performs a linear approximation of the given function for the sake of computational efficiency. This means the computations performed are very different from the function provided, but the results closely approximate those of the actual function within the relevant range. See Fig. \ref{fig:SND_comp} for a comparison.

\subsubsection{Criteria:}
Each temperature from 0 to 100 deg C was tested and compared to the actual formula result. There is some deviation, but not much to make a significant difference. See Fig. \ref{fig:SND_comp}.\newline 

\subsubsection{Working Code:}
\#define SPD\_SND(T) (DIV\_1024(T * (unsigned int)614) + 331)

\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{SND_comp}
	\caption{Comparison between SPD\_SND() Macro output and actual function value}
	\label{fig:SND_comp}
\end{figure}

\subsection{IR\_CONV Macro:}
\subsubsection{Status:}
Working as of 1:40pm 30/9/2014 - Grant

\subsubsection{Description:}
This macro converts the AD result into a range in mm, based on experimental readings from the IR Sensor.

\subsubsection{Criteria:}
This macro has been tested with a range of different input values. Each input returned a distance within a couple of centimetres of the experimental data (which was within the experimental error). See Fig. \ref{fig:IRExperimentalData} for the sensor profile.

\begin{figure}
\centering
\includegraphics[width=1\linewidth]{"IR Experimental Data"}
\caption{IR Experimental Data - Sensor output profile}
\label{fig:IRExperimentalData}
\end{figure}


\subsubsection{Working Code:}
\#define IR\_CONV(ad) ((unsigned long)237411 / (ad) - 65) 

\subsection{calibrateRange:}
\subsubsection{Status:}

\subsubsection{Description:}

\subsubsection{Criteria:}

\subsubsection{Working Code:}

\subsection{rawRange:}
\subsubsection{Status:}
untested as of 11am 26/9/2014 - Grant

\subsubsection{Description:}
Accessor function - simply returns the uncalibrated sensor output from the last range calculation.

\subsubsection{Criteria:}

\subsection{range:}
\subsubsection{Status:}
Untested as of 11am 26/9/14 - Grant

\subsubsection{Description:}
This function performs a read of both the ultrasonic and IR sensors, fuses them and calibrates the result. The current version simply averages the IR and ultrasonic ranges as an initial fusion method.

\subsubsection{Criteria:}

\subsection{rangeIR:}
\subsubsection{Status:}
Untested as of 11am 26/9/14 - Grant

\subsubsection{Description:}
This function performs a read of the IR sensor, calibrates it and returns the result.

\subsubsection{Criteria:}
This function has been tested with a range of different ranges (using a book and measuring the distance from the IR sensor with a tape measure). In each case the calculated distance was within around 30mm of the actual distance.

\subsubsection{Working Code:}
unsigned int rangeIR(void) \newline
\{ \newline
	unsigned int ad\_result; \newline
	unsigned int range; \newline
	
	ad\_result = sampleIR(10); \newline
	
	if (ad\_result $<$ 100) return 0; \newline
	
	range = IR\_CONV(ad\_result); \newline
	
	return range + calibration\_offset\_IR; \newline
\} \newline

\subsection{SampleIR:}
\subsubsection{Status:}
Working as of 4pm 30/9/2014 - Grant

\subsubsection{Description:}
This function performs a specified number of reads of the IR sensor and returns the average.

\subsubsection{Criteria:}
This function has been tested using different ranges for the IR sensor, and each time it has returned the (approximately) correct result.

\subsubsection{Working Code:}
unsigned int sampleIR(char numSamples) \newline
{\newline
	unsigned long int sum = 0; \newline
	unsigned int temp; \newline
	char i = 0; \newline
	
	SetChanADC(ADC\_IR\_READ); \newline
	
	for (i = 0; i $<$ numSamples; i++) \newline
	{ \newline
		ADCON0bits.GO = 1; \newline
		while (ADCON0bits.GO\_NOT\_DONE); \newline
		temp = ADRES $>>$ 6; \newline
		sum += temp; \newline
	} \newline
	
	temp = sum / (unsigned int)numSamples; \newline
	return temp; \newline
}

\subsection{rangeUS:}
\subsubsection{Status:}
Untested as of 11am 26/9/2014 - Grant

\subsubsection{Description:}
This function performs a read of the Ultrasonic sensor (if not already started), calibrates it and returns the result.

\subsection{ConfigureAD:}
\subsubsection{Status:}
Working as of 4pm 30/9/2014 - Grant

\subsubsection{Description:}
This function configures the ADC so that it can subsequently be used (immediately after).

\subsubsection{Criteria:}
There are few testing methods that can be applied to this function in isolation, but after running this function the ADC sampling functions are running properly, so we assume that it is correct. Any future ADC problems should begin with an analysis of this function.

\subsubsection{Working Code:}
void configureAD(void) \newline
{ \newline
	int i = 0; \newline
	TRISA = 0xFF; \newline
	 
	ADCON0 = 0x41; \newline
	ADCON1 = 0x0E; \newline
	
	for (i = 0; i < 1000; i++); \newline
} \newline

\subsection{BeginUS:}
\subsubsection{Status:}
Untested as of 12pm 26/9/2014

\subsubsection{Description:}
This function begins an ultrasonic scan and returns. The returning echo will be serviced by an interrupt and the value will be stored in the range module for the next rangeUS call.

\subsection{rangeISR:}
\subsubsection{Status:}
Untested as of 12pm 26/9/2014 - Grant

\subsubsection{Description:}
This function acts as the service routine for the range module. The exact function will depend on the implementation of the range module and what interrupts are used.

\subsubsection{Criteria:}

\newpage
\section{Tracking}

\subsection{ConfigureBase:}
\subsubsection{Status:}
Currently incomplete and untested as of 12:15pm 26/9/2014 - Grant

\subsubsection{Description:}
This function configures the pan tilt mechanism (which is acting as the base) so that it is ready for initial use.

\subsubsection{Criteria:}

\subsection{Search:}
\subsubsection{Status:}
Currently incomplete and untested as of 12:15pm 26/9/2014 - Grant

\subsubsection{Description:}
This function increments the pan tilt mechanism in a search pattern.

\subsubsection{Criteria:}

\subsection{trackingISR:}
\subsubsection{Status:}
Untested as of 1:20pm 26/9/2014 - Grant

\subsubsection{Description:}
This function acts as the ISR for the tracking module. The exact functionality will depend on what interrupts are associated with the tracking module, and how they are implemented.

\subsubsection{Criteria:}


\subsection{Edge:}
\subsubsection{Status:}
Currently untested as of 1:20pm 26/9/2014

\subsubsection{Description:}
This function finds the edge of the target in both the azimuth and declination degrees of freedom, and uses that to find (and track) the centre of the target. It could also be used as a rudimentary target verification based on the approximate size of the target.

\subsubsection{Criteria:}

\newpage
\section{Serial}
\subsection{Push Macro:}
\subsubsection{Status:}
Working as of 1:45pm 26/9/2014 - Grant

\subsubsection{Description:}
This macro pushes a byte onto a circular buffer. If the buffer is full then it begins overwriting the first data in the buffer.

\subsubsection{Criteria:}
This macro has been tested by pushing a byte onto an empty buffer, a partially filled buffer and a completely filled buffer. In each case the result was as documented.

\subsubsection{Working code:}
\#define push(byte, buf) buf.data[buf.head] = byte; if(full(buf)) incMod(buf.tail); incMod(buf.head)

\subsection{Pop Macro:}
\subsubsection{Criteria:}
Working as of 2:00pm 26/9/2014 - Grant

\subsubsection{Description:}
This macro pops a byte from a circular buffer. If the buffer is empty it returns whatever is in the first element location and does not change the pointers.

\subsubsection{Criteria:}
This macro has been tested with both empty and non-empty buffers and in each case it functions as documented.

\subsubsection{Working Code:}
\#define pop(buf) buf.data[buf.tail]; if (!empty(buf)) incMod(buf.tail)

\subsection{Init Macro:}
\subsubsection{Status:}
Working as of 2pm 26/9/2014 - Grant

\subsubsection{Description:}
This macro initialises a buffer before it can be used - It initializes the pointers to zero. This function will also completely clear a circular buffer.

\subsubsection{Criteria:}
This macro was tested by simply operating on a circularBuffer which was not previously initialized and making sure that it was subsequently initialised.

\subsubsection{Working Code:}
\#define init(buf) buf.head = 0; buf.tail = 0

\subsection{Peek Macro:}
\subsubsection{Status:}
Working as of 2:05pm 26/9/2014 - Grant

\subsubsection{Description:}
This macro returns the next byte that will be popped off the buffer, without removing that element from the buffer. If the buffer is empty it will simply return whatever happens to be in the first element.

\subsubsection{Criteria:}
This macro was tested by simply operating on a macro several times (between which push and pop operations were implemented) and making sure the correct thing was returned.

\subsubsection{Working Code:}
\#define peek(buf) buf.data[buf.tail]

\subsection{Full Macro:}
\subsubsection{Status:}
Working as of 2:05pm 26/9/2014 - Grant

\subsubsection{Description:}
This macro returns non-zero is the buffer is full, and zero otherwise.

\subsubsection{Criteria:}
This macro was tested by operating on a number of circular buffers, both full and not full (including empty), and in each case it returned the correct thing.

\subsubsection{Working Code:}
\#define full(buf) (buf.tail == (buf.head + 1) \% BUFFERLENGTH)

\subsection{Empty:}
\subsubsection{Status:}
Working as of 2:10pm 26/9/2014 - Grant

\subsubsection{Description:}
This macro returns non-zero if the buffer is empty. Otherwise it returns zero.

\subsubsection{Criteria:}
This macro was tested on both empty and non-empty buffers, including full buffers. In all cases the macro returned the expected result.

\subsubsection{Working Code:}
\#define empty(buf) (buf.head == buf.tail)

\subsection{IncMod Macro:}
\subsubsection{Status:}
Working as of 2:30pm 26/9/2014 - Grant

\subsubsection{Description:}
This macro increments a buffer pointer and takes the modulus with the buffer length (defined by BUFFERLENGTH), which will loop back to zero, making the buffer circular.

\subsubsection{Criteria:}
This macro has been tested with a range of values from 0 to BUFFERLENGTH. In each case the macro returned the response as documented.

\subsubsection{Working Code:}
\#define incMod(ptr) (ptr = ++ptr \% BUFFERLENGTH)

\subsection{ConfigureSerial:}
\subsubsection{Remark:}
The baud rate set in this function is dependant on the clock speed of the processor. On the PICDEM board, and other PIC's this is 4MHz. On the minimal board it is a 10MHz clock.

\subsubsection{Status:}
Working as of 11:25am 1/10/2014 - Grant

\subsubsection{Description:}
This function sets up and configures the serial UART for communication to the remote terminal.

\subsubsection{Criteria:}
While there is no way to properly test this function in isolation the serial is working after this function has configured the serial.

\subsubsection{Working Code:}
void configureSerial(void) \newline
\{ \newline
	INTCONbits.GIEH = 1; \newline
	INTCONbits.GIEL = 1; \newline
	RCONbits.IPEN = 1; \newline
	
	init(transmit\_buffer); \newline
	init(receive\_buffer); \newline
	
	//OpenUSART(USART\_TX\_INT\_ON \& USART\_RX\_INT\_ON \& USART\_BRGH\_HIGH \& USART\_EIGHT\_BIT \& USART\_ASYNCH\_MODE, 25);
	OpenUSART(USART\_TX\_INT\_ON \& USART\_RX\_INT\_ON \& USART\_BRGH\_HIGH \& USART\_EIGHT\_BIT \& USART\_ASYNCH\_MODE, 64);
\}

\subsection{Transmit:}
\subsubsection{Status:}
Working as of 11:20am 1/10/2014 - Grant

\subsubsection{Description:}
This function pushes a string onto the serial transmit buffer and enables the transmit interrupt to begin transmitting the buffer (if not already transmitting).

\subsubsection{Criteria:}
This function has been tested by sending strings of different lengths and observing the transmission on terra term. The function appears to be transmitting all strings properly.

\subsubsection{Working Code:}
void transmit(char *string) \newline
\{ \newline
	for (; *string; string++) \newline
	\{ \newline
		push(*string, transmit\_buffer); \newline
	\} \newline
	
	if (empty(transmit\_buffer)) return; \newline
	
	TX\_INT\_ENABLE(); \newline
\} \newline

\subsection{receiveEmpty:}
\subsubsection{Status:}
Working as of 2:50pm 26/9/2014 - Grant

\subsubsection{Description:}
This function returns non-zero if the receive buffer is empty. Otherwise it returns 0.

\subsubsection{Criteria:}
This function was tested in isolation by creating a circular buffer and calling the function between push and pop actions to test empty, non-empty and full cases. In each case the the function returned the expected result.

\subsubsection{Working Code:}
char receiveEmpty(void)
{
	return empty(receive\_buffer);
}


\subsection{receivePeek}
\subsubsection{Status:}
Working as of 2:55pm 26/9/2014 - Grant

\subsubsection{Description:}
This function applies the peek macro to the receive buffer and returns the result.

\subsubsection{Criteria:}
The function was tested in isolation on a circular buffer in full, empty and non-empty cases, and each time the function returned the correct result.

\subsubsection{Working Code:}
char receivePeek(void)
{
	return peek(receive\_buffer);
}

\subsection{receivePop:}
\subsubsection{Status:}
Working as of 3pm 26/9/2014 - Grant

\subsubsection{Description:}
This function applies the pop macro to the receive buffer and returns the result. Note: the push, pop and init macros are multiple lines and cannot by used in a single return statement like peek and empty.

\subsubsection{Criteria:}
The function was tested in isolation on a circular buffer in full, empty and non-empty cases. Each time the result was as outlined in the documentation.

\subsubsection{Working Code:}
char receivePop(void)
{
	char c = pop(receive\_buffer);
	return c;
}

\subsection{serialISR:}
\subsubsection{Status:}
Working as of 11:15am 1/10/2014 - Grant

\subsubsection{Description:}
This function acts as the interrupt service routine for the serial module. The primary purpose will be to handle the receive and transmit interrupts.

\subsubsection{Criteria:}
This function has been tested with transmit and receive operations. The module has been tested transmitting strings and receiving data, so the ISR function is working as all serial goes through the interrupt.

\subsubsection{Working Code:}
void serialISR(void) \newline
\{ \newline
	unsigned char data; \newline
	
	if (TX\_INT) \newline
	\{ \newline
		if (empty(transmit\_buffer))
		\{ \newline
			TX\_INT\_DISABLE(); \newline
			return; \newline
		\} \newline
		
		data = pop(transmit\_buffer); \newline
		WriteUSART(data); \newline
		
		TX\_INT\_CLEAR(); \newline
	\} \newline
	else if (RC\_INT) \newline
	\{ \newline
		data = ReadUSART(); \newline
		
		push(data, receive\_buffer); \newline
		
		RC\_INT\_CLEAR(); \newline
	\} \newline
\} \newline

\subsection{receiveCR}
\subsubsection{Status:}
Currently untested as of 10:30 1/10/2014 - Grant

\subsubsection{Description:}
This function returns non-zero if a carriage return has been received. Otherwise it returns zero.

\subsubsection{Criteria:}


\subsection{readString}
\subsubsection{Status:}
Currently untested as of 10:30 1/10/2014 - Grant

\subsubsection{Description:}
This function returns all received data up to a carriage return, placing it in the location pointed to by *string.

\subsubsection{Criteria:}

\section{Pan Tilt:}

\subsection{SERVO\_TOGGLE Macro}

\subsubsection{REVISION:}
In the latest version of the code this macro is no longer included. It is kept in this document for record purposes. Grant 4:10pm 30/9/2014.

\subsubsection{Status:}
Working as of 12:30 28/9/2014 - Grant

\subsubsection{Description:}
Toggles the pins used to generate the PWM signal to the servos. There is a SERVO\_INIT() macro which initialises the pins, and AZ\_PWM\_PIN and IN\_PWM\_PIN macros to pass this this macro. At the moment this macro uses PORTC for the PWM pins. The exact pins in PORTC are determined by the AZ\_PWM\_PIN and IN\_PWM\_PIN macros.

\subsubsection{Criteria:}
This macro was tested with different combinations of AZ\_PWM\_PIN and IN\_PWM\_PIN arguments, as well as different starting conditions. In each case the result was as documented.

\subsubsection{Working Code:}
\#define SERVO\_TOGGLE(tog) (PORTC = (PORTC \& ~PWM\_PINS) | ((PORTC \& PWM\_PINS) \^ (tog)))

\subsection{ConfigureBase:}
\subsubsection{REVISION:}
This function has changed significantly in the latest version. The previous version is kept for archive purposes.

\subsubsection{Status:}
Working as of 11:15pm 28/9/2014 - Grant

\subsubsection{Description:}
Configures the PWM mechanisms to control the pan tilt servo's.

\subsubsection{Criteria:}
This function has been tested by calling the function and checking the output on RC0 and RC1, the PWM outputs.

\subsubsection{Working code:}
void configureBase(void) \newline
\{\newline
	unsigned char config;\newline
	
	DirectionState zero = { 0, 0 };\newline
	global\_delay = direction2Delay(zero);\newline
	
	INTCONbits.GIEH = 1;\newline
	INTCONbits.GIEL = 1;\newline
	
	RCONbits.IPEN = 1;\newline
	
	SERVO\_INIT();\newline
	
	config = T1\_16BIT\_RW \& T1\_PS\_1\_1 \& T1\_OSC1EN\_OFF \& T1\_SYNC\_EXT\_OFF \& T1\_SOURCE\_INT;\newline
	
	OpenTimer1(config);\newline
	
	SetTmrCCPSrc(T1\_CCP1\_T3\_CCP2);\newline
	
	config = COM\_INT\_ON \& COM\_UNCHG\_MATCH;\newline
	
	OpenCompare1(config, PWM\_PERIOD);\newline
\}\newline

\subsubsection{Working code (OBSOLETE):}
void configureBase(void) \newline
\{ \newline
unsigned char config; \newline
DirectionState zero = { 14, 0 }; \newline
global\_delay = direction2Delay(zero);\newline
INTCONbits.GIEH = 1;\newline
INTCONbits.GIEL = 1;\newline
RCONbits.IPEN = 1;\newline
SERVO\_INIT();\newline
config = T1\_16BIT\_RW \& T1\_PS\_1\_1 \& T1\_OSC1EN\_OFF \& T1\_SYNC\_EXT\_OFF \& T1\_SOURCE\_INT; \newline
OpenTimer1(config);\newline
SetTmrCCPSrc(T1\_CCP1\_T3\_CCP2);\newline
config = COM\_INT\_ON \& COM\_UNCHG\_MATCH;\newline
OpenCompare1(config, PWM\_PERIOD);\newline
\}

\subsection{panTiltISR:}
\subsubsection{REVISION:}
In the latest version this function has changed significantly - while its function has remained the same. For archive purposes the original code is kept.

\subsubsection{Status:}
Working as of 11:20pm 28/9/2014 - Grant

\subsubsection{Description:}
This function acts as the Interrupt Service Routine for the pan tilt mechanism. This function creates the PWM's on the output pins.

\subsubsection{Criteria:}
This function has been tested on a range of different periods on each of the degrees of freedom.

\subsubsection{Working Code:}
void panTiltISR(void) \newline
\{ \newline
	unsigned int timer\_value; \newline
	static Delay current\_delay;\newline
	unsigned char i = 0;\newline
	
	if (CCP1\_INT) \newline
	\{ \newline
		timer\_value = ReadTimer1();\newline
		
		if (timer\_value > PWM\_PERIOD - LATENCY) \newline
		\{ \newline
			IN\_PWM\_PIN = 1;\newline
			WriteTimer1(0);\newline     //Clear timer2
			current\_delay = global\_delay;\newline   //update the static delay
			OpenCompare1(COM\_INT\_ON \& COM\_UNCHG\_MATCH, current\_delay.InclinationDelay);\newline
		\} \newline
		else if (timer\_value $>$ current\_delay.AzimuthDelay) \newline
		\{ \newline
			AZ\_PWM\_PIN = 0;\newline
			OpenCompare1(COM\_INT\_ON \& COM\_UNCHG\_MATCH, PWM\_PERIOD);\newline
		\} \newline
		else if (timer\_value $>$ PWM\_HALF\_PERIOD - LATENCY) \newline
		\{ \newline
			AZ\_PWM\_PIN = 1;\newline
			OpenCompare1(COM\_INT\_ON \& COM\_UNCHG\_MATCH, current\_delay.AzimuthDelay);\newline
		\} \newline
		else if (timer\_value $>$ current\_delay.InclinationDelay) \newline
		\{ \newline
			IN\_PWM\_PIN = 0;\newline
			OpenCompare1(COM\_INT\_ON \& COM\_UNCHG\_MATCH, PWM\_HALF\_PERIOD);\newline
		\} \newline
		
		PIR1bits.CCP1IF = 0;\newline
	\} \newline
\} \newline

\subsubsection{Working Code (OBSOLETE):}
void panTiltISR(void)\newline
\{ \newline
	unsigned int timer\_value;\newline
	static Delay current\_delay;\newline
	unsigned char i = 0;\newline
	
	if (CCP1\_INT)\newline
	\{\newline
		timer\_value = ReadTimer1();\newline
		
		if (timer\_value > PWM\_PERIOD - LATENCY)\newline
		\{\newline
			SERVO\_INIT();\newline
			WriteTimer1(0);\newline
			current\_delay = global\_delay;\newline
			OpenCompare1(COM\_INT\_ON \& COM\_UNCHG\_MATCH, current\_delay.short\_delay.delay\_time);\newline
		\}\newline
		else if (timer\_value > current\_delay.long\_delay.delay\_time)\newline
		\{\newline
			SERVO\_TOGGLE(current\_delay.long\_delay.toggle\_bits);\newline
			OpenCompare1(COM\_INT\_ON \& COM\_UNCHG\_MATCH, PWM\_PERIOD); \newline
		\}\newline
		else if (timer\_value > current\_delay.short\_delay.delay\_time)\newline
		\{\newline
			SERVO\_TOGGLE(current\_delay.short\_delay.toggle\_bits);\newline
			for (; i < current\_delay.micro\_delay.iterations; i++);\newline
			SERVO\_TOGGLE(current\_delay.micro\_delay.toggle\_bits);\newline
			OpenCompare1(COM\_INT\_ON \& COM\_UNCHG\_MATCH, current\_delay.long\_delay.delay\_time);\newline
		\}\newline
		
		PIR1bits.CCP1IF = 0;\newline
	\}\newline
\}\newline

\subsection{direction2Delay:}
\subsubsection{REVISION:}
This function has been changed significantly in the most recent revision. The previous version has been retained in this document for archival purposes.

\subsubsection{Status:}
Working as of 11:25pm 28/9/2014 - Grant

\subsubsection{Description:}
This function converts a given Azimuth and Inclination into a delay struct which is then used to create the desired PWM which will result in the given azimuth and inclination.

\subsubsection{Criteria:}
This function has been tested with a range of different azimuths and inclinations both mathematically, and by inputting the PWM's into the servo's to check the actual position.

\subsubsection{Working Code:}
Delay direction2Delay(DirectionState dir) \newline
\{\newline
	Delay result; \newline
	unsigned int az, inc; \newline
	
	az = 1000 + (dir.azimuth + DIV\_2(arcRange.azimuth) + calibration\_offset.azimuth) * (long int)1000 / arcRange.azimuth; \newline
	inc = 1000 + (dir.inclination + DIV\_2(arcRange.inclination) + calibration\_offset.inclination) * (long int)1000 / arcRange.inclination;  \newline
	
	validate(\&az); \newline
	validate(\&inc); \newline
	
	result.AzimuthDelay = az + PWM\_HALF\_PERIOD; \newline
	result.InclinationDelay = inc - LATENCY; \newline
	
	return result; \newline
\} \newline

\subsubsection{Working Code (OBSELETE):}
Delay direction2Delay(DirectionState dir) \newline
\{\newline
	Delay result;\newline
	unsigned int az\_delay;\newline
	unsigned int in\_delay;\newline
	unsigned int micro\_delay;\newline
	
	az\_delay = dir.azimuth * (unsigned long int)1000 / ARC\_RANGE + 1000;\newline
	in\_delay = dir.inclination * (unsigned long int)1000 / ARC\_RANGE + 1000;\newline
	
	validate(\&az\_delay);\newline
	validate(\&in\_delay);\newline
	
	if (az\_delay < in\_delay)\newline
	\{\newline
		result.short\_delay.delay\_time = az\_delay - LATENCY;\newline
		result.long\_delay.delay\_time = in\_delay - LATENCY;\newline
		result.short\_delay.toggle\_bits = AZ\_PWM\_PIN;\newline
		result.long\_delay.toggle\_bits = IN\_PWM\_PIN;\newline
	\}\newline
	else\newline
	\{\newline
		result.long\_delay.delay\_time = az\_delay - LATENCY;\newline
		result.short\_delay.delay\_time = in\_delay - LATENCY;\newline
		result.long\_delay.toggle\_bits = AZ\_PWM\_PIN;\newline
		result.short\_delay.toggle\_bits = IN\_PWM\_PIN;\newline
	\}\newline
	
	micro\_delay = result.long\_delay.delay\_time - result.short\_delay.delay\_time;\newline
	if (micro\_delay < min\_sep)\newline
	\{\newline
		result.short\_delay.toggle\_bits = AZ\_PWM\_PIN | IN\_PWM\_PIN;\newline
		result.micro\_delay.iterations = 0;\newline
		result.micro\_delay.toggle\_bits = 0;\newline
		result.long\_delay.delay\_time = PWM\_PERIOD;\newline
	\}\newline
	else if (micro\_delay < LATENCY)\newline
	\{\newline
		result.micro\_delay.iterations = (micro\_delay - min\_sep) / min\_inc;\newline
		result.micro\_delay.toggle\_bits = az\_delay > in\_delay ? AZ\_PWM\_PIN : IN\_PWM\_PIN;\newline\
		result.long\_delay.delay\_time = PWM\_PERIOD;\newline
	\}\newline
	else\newline
	\{\newline
		result.micro\_delay.iterations = 0;\newline
		result.micro\_delay.toggle\_bits = 0;\newline
	\}\newline
	
	return result;\newline
\}\newline

\subsection{delay2Direction:}
\subsubsection{Status:}
Working as of 4:30pm 30/9/2014 - Grant

\subsubsection{Description:}
This function converts a delay back into into the direction object that would be used to create it via the direction2Delay function.

\subsubsection{Criteria:}
This function has been tested by specifying a direction, then converting it into a delay via the direction2delay function. This was then sent to the servos to make sure the delay is correct, and then sent to the delay2Direction function and compared to the original direction object.

\subsubsection{Working Code:}
DirectionState delay2Direction(Delay dly) \newline
\{ \newline
	DirectionState ret; \newline
	
	ret.azimuth = ((dly.AzimuthDelay - PWM\_HALF\_PERIOD - 1000) * (long int)arcRange.azimuth + 500) / 1000 - DIV\_2(arcRange.azimuth) - calibration\_offset.azimuth; \newline
	ret.inclination = ((dly.InclinationDelay + LATENCY - 1000) * (long int)arcRange.inclination + 500) / 1000 - DIV\_2(arcRange.inclination) - calibration\_offset.inclination; \newline
	
	return ret; \newline
\} \newline

\subsection{Validate:}
\subsubsection{Status:}
Currently working as of 1:30pm 26/9/2014 - Grant

\subsubsection{Description:}
This function validates a given delay to ensure that it is between 1000ms and 2000ms, coercing it if not.

\subsubsection{Criteria:}
This function was tested by passing it values of 100, 1500 and 10000, which includes one of each possible case. In each case the function responded appropriately and gave the desired response.

\subsubsection{Working Code:}
void validate(unsigned int *delay) \newline
\{ \newline
	if (*delay $<$ 1000) \newline
	\{ \newline
		*delay = 1000; \newline
	\} \newline
	if (*delay $>$ 2000) \newline
	\{ \newline
		*delay = 2000; \newline
	\} \newline
\}\newline

\subsection{moveBase:}
\subsubsection{Status:}
Currently incomplete and untested as of 1:20pm 26/9/2014 - Grant

\subsubsection{Description:} 
This function will move the pan tilt mechanism to the given inclination and declination.

\subsubsection{Criteria:}

\newpage



\end{document}
